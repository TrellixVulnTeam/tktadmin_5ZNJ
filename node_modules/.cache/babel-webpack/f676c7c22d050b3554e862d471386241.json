{"ast":null,"code":"// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = function () {\n  function Positioning() {}\n\n  Positioning.prototype.getAllStyles = function (element) {\n    return window.getComputedStyle(element);\n  };\n\n  Positioning.prototype.getStyle = function (element, prop) {\n    return this.getAllStyles(element)[prop];\n  };\n\n  Positioning.prototype.isStaticPositioned = function (element) {\n    return (this.getStyle(element, 'position') || 'static') === 'static';\n  };\n\n  Positioning.prototype.offsetParent = function (element) {\n    var offsetParentEl = element.offsetParent || document.documentElement;\n\n    while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n      offsetParentEl = offsetParentEl.offsetParent;\n    }\n\n    return offsetParentEl || document.documentElement;\n  };\n\n  Positioning.prototype.position = function (element, round) {\n    if (round === void 0) {\n      round = true;\n    }\n\n    var elPosition;\n    var parentOffset = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    if (this.getStyle(element, 'position') === 'fixed') {\n      elPosition = element.getBoundingClientRect();\n    } else {\n      var offsetParentEl = this.offsetParent(element);\n      elPosition = this.offset(element, false);\n\n      if (offsetParentEl !== document.documentElement) {\n        parentOffset = this.offset(offsetParentEl, false);\n      }\n\n      parentOffset.top += offsetParentEl.clientTop;\n      parentOffset.left += offsetParentEl.clientLeft;\n    }\n\n    elPosition.top -= parentOffset.top;\n    elPosition.bottom -= parentOffset.top;\n    elPosition.left -= parentOffset.left;\n    elPosition.right -= parentOffset.left;\n\n    if (round) {\n      elPosition.top = Math.round(elPosition.top);\n      elPosition.bottom = Math.round(elPosition.bottom);\n      elPosition.left = Math.round(elPosition.left);\n      elPosition.right = Math.round(elPosition.right);\n    }\n\n    return elPosition;\n  };\n\n  Positioning.prototype.offset = function (element, round) {\n    if (round === void 0) {\n      round = true;\n    }\n\n    var elBcr = element.getBoundingClientRect();\n    var viewportOffset = {\n      top: window.pageYOffset - document.documentElement.clientTop,\n      left: window.pageXOffset - document.documentElement.clientLeft\n    };\n    var elOffset = {\n      height: elBcr.height || element.offsetHeight,\n      width: elBcr.width || element.offsetWidth,\n      top: elBcr.top + viewportOffset.top,\n      bottom: elBcr.bottom + viewportOffset.top,\n      left: elBcr.left + viewportOffset.left,\n      right: elBcr.right + viewportOffset.left\n    };\n\n    if (round) {\n      elOffset.height = Math.round(elOffset.height);\n      elOffset.width = Math.round(elOffset.width);\n      elOffset.top = Math.round(elOffset.top);\n      elOffset.bottom = Math.round(elOffset.bottom);\n      elOffset.left = Math.round(elOffset.left);\n      elOffset.right = Math.round(elOffset.right);\n    }\n\n    return elOffset;\n  };\n\n  Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n    var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n    var targetElStyles = this.getAllStyles(targetElement);\n    var targetElBCR = targetElement.getBoundingClientRect();\n    var placementPrimary = placement.split('-')[0] || 'top';\n    var placementSecondary = placement.split('-')[1] || 'center';\n    var targetElPosition = {\n      'height': targetElBCR.height || targetElement.offsetHeight,\n      'width': targetElBCR.width || targetElement.offsetWidth,\n      'top': 0,\n      'bottom': targetElBCR.height || targetElement.offsetHeight,\n      'left': 0,\n      'right': targetElBCR.width || targetElement.offsetWidth\n    };\n\n    switch (placementPrimary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n        break;\n\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height;\n        break;\n\n      case 'left':\n        targetElPosition.left = hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n        break;\n\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width;\n        break;\n    }\n\n    switch (placementSecondary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top;\n        break;\n\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n        break;\n\n      case 'left':\n        targetElPosition.left = hostElPosition.left;\n        break;\n\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n        break;\n\n      case 'center':\n        if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n          targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n        } else {\n          targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n        }\n\n        break;\n    }\n\n    targetElPosition.top = Math.round(targetElPosition.top);\n    targetElPosition.bottom = Math.round(targetElPosition.bottom);\n    targetElPosition.left = Math.round(targetElPosition.left);\n    targetElPosition.right = Math.round(targetElPosition.right);\n    return targetElPosition;\n  }; // get the availble placements of the target element in the viewport dependeing on the host element\n\n\n  Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n    var availablePlacements = [];\n    var hostElemClientRect = hostElement.getBoundingClientRect();\n    var targetElemClientRect = targetElement.getBoundingClientRect();\n    var html = document.documentElement;\n    var windowHeight = window.innerHeight || html.clientHeight;\n    var windowWidth = window.innerWidth || html.clientWidth;\n    var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n    var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2; // left: check if target width can be placed between host left and viewport start and also height of target is\n    // inside viewport\n\n    if (targetElemClientRect.width < hostElemClientRect.left) {\n      // check for left only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 && windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'left');\n      } // check for left-top and left-bottom\n\n\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n    } // top: target height is less than host top\n\n\n    if (targetElemClientRect.height < hostElemClientRect.top) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 && windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'top');\n      }\n\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n    } // right: check if target width can be placed between host right and viewport end and also height of target is\n    // inside viewport\n\n\n    if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n      // check for right only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 && windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'right');\n      } // check for right-top and right-bottom\n\n\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n    } // bottom: check if there is enough space between host bottom and viewport end for target height\n\n\n    if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 && windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n      }\n\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n    }\n\n    return availablePlacements;\n  };\n  /**\n   * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n   * primaryplacement: left|right\n   * availablePlacementArr: array in which available placemets to be set\n   */\n\n\n  Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n    var html = document.documentElement; // check for left-bottom\n\n    if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n    }\n\n    if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n    }\n  };\n  /**\n   * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n   * primaryplacement: top|bottom\n   * availablePlacementArr: array in which available placemets to be set\n   */\n\n\n  Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n    var html = document.documentElement; // check for left-bottom\n\n    if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n    }\n\n    if (targetElemClientRect.width <= hostElemClientRect.right) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n    }\n  };\n\n  return Positioning;\n}();\n\nexport { Positioning };\nvar positionService = new Positioning();\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * */\n\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n  var placementVals = Array.isArray(placement) ? placement : [placement]; // replace auto placement with other placements\n\n  var hasAuto = placementVals.findIndex(function (val) {\n    return val === 'auto';\n  });\n\n  if (hasAuto >= 0) {\n    ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top', 'left-bottom', 'right-top', 'right-bottom'].forEach(function (obj) {\n      if (placementVals.find(function (val) {\n        return val.search('^' + obj) !== -1;\n      }) == null) {\n        placementVals.splice(hasAuto++, 1, obj);\n      }\n    });\n  } // coordinates where to position\n\n\n  var topVal = 0,\n      leftVal = 0;\n  var appliedPlacement; // get available placements\n\n  var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n\n  var _loop_1 = function _loop_1(item, index) {\n    // check if passed placement is present in the available placement or otherwise apply the last placement in the\n    // passed placement list\n    if (availablePlacements.find(function (val) {\n      return val === item;\n    }) != null || placementVals.length === index + 1) {\n      appliedPlacement = item;\n      var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n      topVal = pos.top;\n      leftVal = pos.left;\n      return \"break\";\n    }\n  }; // iterate over all the passed placements\n\n\n  for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n    var _b = _a[_i],\n        item = _b.item,\n        index = _b.index;\n\n    var state_1 = _loop_1(item, index);\n\n    if (state_1 === \"break\") break;\n  }\n\n  targetElement.style.top = topVal + \"px\";\n  targetElement.style.left = leftVal + \"px\";\n  return appliedPlacement;\n} // function to get index and item of an array\n\nfunction toItemIndexes(a) {\n  return a.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  });\n}","map":{"version":3,"sources":["../src/positioning.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = (function () {\n    function Positioning() {\n    }\n    Positioning.prototype.getAllStyles = function (element) { return window.getComputedStyle(element); };\n    Positioning.prototype.getStyle = function (element, prop) { return this.getAllStyles(element)[prop]; };\n    Positioning.prototype.isStaticPositioned = function (element) {\n        return (this.getStyle(element, 'position') || 'static') === 'static';\n    };\n    Positioning.prototype.offsetParent = function (element) {\n        var offsetParentEl = element.offsetParent || document.documentElement;\n        while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n            offsetParentEl = offsetParentEl.offsetParent;\n        }\n        return offsetParentEl || document.documentElement;\n    };\n    Positioning.prototype.position = function (element, round) {\n        if (round === void 0) { round = true; }\n        var elPosition;\n        var parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };\n        if (this.getStyle(element, 'position') === 'fixed') {\n            elPosition = element.getBoundingClientRect();\n        }\n        else {\n            var offsetParentEl = this.offsetParent(element);\n            elPosition = this.offset(element, false);\n            if (offsetParentEl !== document.documentElement) {\n                parentOffset = this.offset(offsetParentEl, false);\n            }\n            parentOffset.top += offsetParentEl.clientTop;\n            parentOffset.left += offsetParentEl.clientLeft;\n        }\n        elPosition.top -= parentOffset.top;\n        elPosition.bottom -= parentOffset.top;\n        elPosition.left -= parentOffset.left;\n        elPosition.right -= parentOffset.left;\n        if (round) {\n            elPosition.top = Math.round(elPosition.top);\n            elPosition.bottom = Math.round(elPosition.bottom);\n            elPosition.left = Math.round(elPosition.left);\n            elPosition.right = Math.round(elPosition.right);\n        }\n        return elPosition;\n    };\n    Positioning.prototype.offset = function (element, round) {\n        if (round === void 0) { round = true; }\n        var elBcr = element.getBoundingClientRect();\n        var viewportOffset = {\n            top: window.pageYOffset - document.documentElement.clientTop,\n            left: window.pageXOffset - document.documentElement.clientLeft\n        };\n        var elOffset = {\n            height: elBcr.height || element.offsetHeight,\n            width: elBcr.width || element.offsetWidth,\n            top: elBcr.top + viewportOffset.top,\n            bottom: elBcr.bottom + viewportOffset.top,\n            left: elBcr.left + viewportOffset.left,\n            right: elBcr.right + viewportOffset.left\n        };\n        if (round) {\n            elOffset.height = Math.round(elOffset.height);\n            elOffset.width = Math.round(elOffset.width);\n            elOffset.top = Math.round(elOffset.top);\n            elOffset.bottom = Math.round(elOffset.bottom);\n            elOffset.left = Math.round(elOffset.left);\n            elOffset.right = Math.round(elOffset.right);\n        }\n        return elOffset;\n    };\n    Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n        var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n        var targetElStyles = this.getAllStyles(targetElement);\n        var targetElBCR = targetElement.getBoundingClientRect();\n        var placementPrimary = placement.split('-')[0] || 'top';\n        var placementSecondary = placement.split('-')[1] || 'center';\n        var targetElPosition = {\n            'height': targetElBCR.height || targetElement.offsetHeight,\n            'width': targetElBCR.width || targetElement.offsetWidth,\n            'top': 0,\n            'bottom': targetElBCR.height || targetElement.offsetHeight,\n            'left': 0,\n            'right': targetElBCR.width || targetElement.offsetWidth\n        };\n        switch (placementPrimary) {\n            case 'top':\n                targetElPosition.top =\n                    hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height;\n                break;\n            case 'left':\n                targetElPosition.left =\n                    hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width;\n                break;\n        }\n        switch (placementSecondary) {\n            case 'top':\n                targetElPosition.top = hostElPosition.top;\n                break;\n            case 'bottom':\n                targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n                break;\n            case 'left':\n                targetElPosition.left = hostElPosition.left;\n                break;\n            case 'right':\n                targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n                break;\n            case 'center':\n                if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n                    targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n                }\n                else {\n                    targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n                }\n                break;\n        }\n        targetElPosition.top = Math.round(targetElPosition.top);\n        targetElPosition.bottom = Math.round(targetElPosition.bottom);\n        targetElPosition.left = Math.round(targetElPosition.left);\n        targetElPosition.right = Math.round(targetElPosition.right);\n        return targetElPosition;\n    };\n    // get the availble placements of the target element in the viewport dependeing on the host element\n    Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n        var availablePlacements = [];\n        var hostElemClientRect = hostElement.getBoundingClientRect();\n        var targetElemClientRect = targetElement.getBoundingClientRect();\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight || html.clientHeight;\n        var windowWidth = window.innerWidth || html.clientWidth;\n        var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n        var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2;\n        // left: check if target width can be placed between host left and viewport start and also height of target is\n        // inside viewport\n        if (targetElemClientRect.width < hostElemClientRect.left) {\n            // check for left only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'left');\n            }\n            // check for left-top and left-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n        }\n        // top: target height is less than host top\n        if (targetElemClientRect.height < hostElemClientRect.top) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'top');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n        }\n        // right: check if target width can be placed between host right and viewport end and also height of target is\n        // inside viewport\n        if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n            // check for right only\n            if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 &&\n                windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'right');\n            }\n            // check for right-top and right-bottom\n            this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n        }\n        // bottom: check if there is enough space between host bottom and viewport end for target height\n        if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n            if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 &&\n                windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n                availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n            }\n            this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n        }\n        return availablePlacements;\n    };\n    /**\n     * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\n     * primaryplacement: left|right\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n        }\n        if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n        }\n    };\n    /**\n     * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\n     * primaryplacement: top|bottom\n     * availablePlacementArr: array in which available placemets to be set\n     */\n    Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n        var html = document.documentElement;\n        // check for left-bottom\n        if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n        }\n        if (targetElemClientRect.width <= hostElemClientRect.right) {\n            availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n        }\n    };\n    return Positioning;\n}());\nexport { Positioning };\nvar positionService = new Positioning();\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'left', 'right',\n *   'top-left', 'top-right',\n *   'bottom-left', 'bottom-right',\n *   'left-top', 'left-bottom',\n *   'right-top', 'right-bottom'.\n * */\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n    var placementVals = Array.isArray(placement) ? placement : [placement];\n    // replace auto placement with other placements\n    var hasAuto = placementVals.findIndex(function (val) { return val === 'auto'; });\n    if (hasAuto >= 0) {\n        ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top',\n            'left-bottom', 'right-top', 'right-bottom',\n        ].forEach(function (obj) {\n            if (placementVals.find(function (val) { return val.search('^' + obj) !== -1; }) == null) {\n                placementVals.splice(hasAuto++, 1, obj);\n            }\n        });\n    }\n    // coordinates where to position\n    var topVal = 0, leftVal = 0;\n    var appliedPlacement;\n    // get available placements\n    var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n    var _loop_1 = function (item, index) {\n        // check if passed placement is present in the available placement or otherwise apply the last placement in the\n        // passed placement list\n        if ((availablePlacements.find(function (val) { return val === item; }) != null) || (placementVals.length === index + 1)) {\n            appliedPlacement = item;\n            var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n            topVal = pos.top;\n            leftVal = pos.left;\n            return \"break\";\n        }\n    };\n    // iterate over all the passed placements\n    for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n        var _b = _a[_i], item = _b.item, index = _b.index;\n        var state_1 = _loop_1(item, index);\n        if (state_1 === \"break\")\n            break;\n    }\n    targetElement.style.top = topVal + \"px\";\n    targetElement.style.left = leftVal + \"px\";\n    return appliedPlacement;\n}\n// function to get index and item of an array\nfunction toItemIndexes(a) {\n    return a.map(function (item, index) { return ({ item: item, index: index }); });\n}\n//# sourceMappingURL=positioning.js.map"]},"metadata":{},"sourceType":"module"}